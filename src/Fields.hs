
module Fields (upd) where

import Language.Haskell.TH

upd :: Name -> Q Exp
upd n = do
  p0 <- newName "f"
  p1 <- newName "x"
  return $
    LamE [VarP p0, VarP p1] $
    RecUpdE (VarE p1) [(n, AppE (VarE p0) (AppE (VarE n) (VarE p1)))]

data Foo = Foo { foo :: Int }

upd' :: IO ()
upd' = runQ (upd 'foo) >>= print

{-
 - A more advanced system of records:
 - 1. Declaration generated by a TH splice.
 - 2. The declaration of the datatype does not use record syntax itself.
 - 3. For each field, there will be a generated class with one method which
 -    has the name of the field: class Cf a where f :: t -> a
 - 4. Generated instances of C, where the field has type v, are:
 -    a. Cf v
 -    b. Cf (v -> t)
 -    c. Cf ((v -> v) -> t)
 -       This one will be implemented as: mkModify f f, where the two f's get
 -       bound to the first two instances' functions.
 - 6. It will also be easy to define projections that act like fields.
 -    Simply declare a new class with the three instances. There will be some
 -    tedium in this, however, so we should make a splice which accepts as
 -    input the functions defining the first two instances, and produces as
 -    output the class and all three instances.
 -}

