
module Debug (debug, dprint, dwprint) where

import State
import Types
import X11

import Control.Monad.Maybe
import Control.Monad.Reader
import Control.Monad.State
import Control.Monad.Trans
import Graphics.X11

debugEnabled :: Bool
debugEnabled = True

syncEnabled :: Bool
syncEnabled = False

indent :: String
indent = take 2 $ repeat ' '

class Debug m where
  debugWrite :: String -> m ()

{-
 - It should be possible to get rid of all these varied functions using a
 - class like:
 -   class Foo a b | a -> b where
 -     foo :: a -> m b
 -}

-- Print a string to the debug log.
debug :: (Debug m) => String -> m ()
-- TODO

-- Print a named string to the debug log.
debugN :: (Debug m) => Name -> String -> m ()
-- TODO

-- Print a value to the debug log and return it monadically.
dprint :: (Debug m, Show a) => a -> m a
-- TODO

-- Print a named value to the debug log and return it monadically.
dprintN :: (Debug m, Show a) => Name -> a -> m a
-- TODO

-- Print a variable to the debug log and return it monadically.
dprintT :: Name -> QExp
-- TODO

-- Group log entries generated by a monadic value under a node.
debugM :: (Debug m) => m a -> m a
-- TODO

-- Group log entries generated by a monadic value under a named node.
debugMN :: (Debug m) => Name -> m a -> m a
-- TODO
-- Note: this is not a TH template. It accepts a Name instead of a String so
-- that the names which can be output are the same as those which can be output
-- by debugT.

-- Group log entries generated by a monadic variable under a node.
debugMT :: Name -> QExp
-- TODO

instance Debug (ReaderT X11Env IO) where
  debugWrite xs = do
    if syncEnabled
       then getDisplay >>= liftIO . flip sync False
       else return ()
    if debugEnabled
       then liftIO $ putStrLn xs
       else return ()

instance Debug (MaybeT (StateT World (ReaderT X11Env IO))) where
  debugWrite = lift . lift . debug

class Wrap u w | u -> w where
  wrap   :: u -> w
  unwrap :: w -> u

wrapped :: (Wrap u w) => (w -> a) -> u -> a
wrapped = (. wrap)

dwprint :: (Wrap u w, Show w, Debug m) => u -> m ()
dwprint = wrapped dprint

newtype ShowKeySym = ShowKeySym KeySym

instance Wrap KeySym ShowKeySym where
  wrap = ShowKeySym
  unwrap (ShowKeySym k) = k

instance Show ShowKeySym where
  show = keysymToString . unwrap

